module Generate exposing (files)

{-| -}

import Abi
import Context
import Elm
import EosType
import Generate.Action
import Generate.Action.Metadata
import Generate.GenericTable
import Generate.Table
import Generate.Table.Decoder
import Generate.Table.Metadata
import Generate.Table.Query
import List.Extra as ListX
import String.Extra


files : List String -> List { abi : Abi.Abi, baseUrl : String, contract : String } -> List Elm.File
files base abis =
    List.concat
        [ genericFiles base abis
        , List.concatMap
            (\{ abi, baseUrl, contract } ->
                apiFilesFromAbi base
                    { baseUrl = baseUrl, contract = contract, basePath = base }
                    abi
            )
            abis
        ]


basePrefixedFile :
    List String
    -> { docs : List String }
    -> List Elm.Declaration
    -> Elm.File
basePrefixedFile suffix { docs } =
    Elm.fileWith suffix
        { aliases = []
        , docs =
            \groupsAndMembers ->
                autoGeneratedWarning
                    :: docs
                    ++ makeDocs groupsAndMembers
        }


autoGeneratedWarning : String
autoGeneratedWarning =
    "This file was automatically generated by henriquecbuss/elm-eos. Do not edit it by hand!"


makeDocs : List { group : Maybe String, members : List String } -> List String
makeDocs groupsAndMembers =
    List.map (\group -> Elm.docs { group | members = List.reverse group.members })
        groupsAndMembers


genericFiles : List String -> List { abi : Abi.Abi, baseUrl : String, contract : String } -> List Elm.File
genericFiles base abis =
    let
        contracts : List String
        contracts =
            List.map .contract abis

        contractsAndTables : List ( String, List Abi.Table )
        contractsAndTables =
            List.map
                (\abi -> ( abi.contract, abi.abi.tables ))
                abis

        allTableTypes : List EosType.EosType
        allTableTypes =
            abis
                |> List.concatMap
                    (\{ abi } ->
                        List.concatMap (.columns >> List.map .type_)
                            abi.tables
                    )
                |> ListX.unique

        prefixedFile :
            List String
            -> { docs : List String }
            -> List Elm.Declaration
            -> Elm.File
        prefixedFile suffix =
            basePrefixedFile (base ++ suffix)
    in
    [ prefixedFile [ "Table" ]
        { docs = [ "This file is a way to use tables in a generic way. It's useful if you want to create pages that can display any table. For example, if you want to create a contract explorer. Check out https://henriquecbuss/elm-eos/blob/master/examples/contract-explorer for an example on how to use this module." ]
        }
        ((Generate.GenericTable.type_ base contracts
            |> Elm.exposeWith { exposeConstructor = True, group = Just "Generic table" }
         )
            :: Elm.exposeWith { exposeConstructor = True, group = Just "Generic table" } Generate.GenericTable.metadataType
            :: (Generate.GenericTable.toId base contractsAndTables
                    |> .declaration
                    |> Elm.exposeWith { exposeConstructor = True, group = Just "Building tables" }
               )
            :: Generate.GenericTable.boolToString.declaration
            :: (Generate.GenericTable.columns base contractsAndTables
                    |> .declaration
                    |> Elm.exposeWith { exposeConstructor = True, group = Just "Building tables" }
               )
            :: Generate.GenericTable.wrapCol.declaration
            :: Generate.GenericTable.customColumnHtmlDetails.declaration
            :: Generate.GenericTable.customColumn.declaration
            :: List.map (Generate.GenericTable.columnForType >> .declaration) allTableTypes
            ++ List.concatMap
                (\( contract, tables ) ->
                    List.map
                        (Generate.GenericTable.columnsForTable base contract
                            >> .declaration
                        )
                        tables
                )
                contractsAndTables
        )
    ]


apiFilesFromAbi : List String -> Context.Context -> Abi.Abi -> List Elm.File
apiFilesFromAbi _ context abi =
    let
        fileName : List String -> List String
        fileName suffix =
            Context.prefixed context suffix

        prefixedFile :
            List String
            -> { docs : List String }
            -> List Elm.Declaration
            -> Elm.File
        prefixedFile suffix =
            basePrefixedFile (Context.prefixed context suffix)
    in
    [ prefixedFile [ "Action" ]
        { docs =
            [ "This file contains all of the actions for the "
                ++ context.contract
                ++ " contract. In order to send an action to the blockchain, create an [Action](#Action), [encode](#encode) it, and send through a port to eosjs, or similar."
            ]
        }
        [ Generate.Action.type_ abi.actions
            |> Elm.exposeWith { exposeConstructor = True, group = Just "Action" }
        , Generate.Action.encode context
            |> Elm.exposeWith { exposeConstructor = True, group = Just "Encoding" }
        , Generate.Action.encodeSingleAction abi.actions
            |> Elm.exposeWith { exposeConstructor = True, group = Just "Encoding" }
        , Generate.Action.getName abi.actions
        , Generate.Action.fromDict abi.actions
            |> Elm.exposeWith { exposeConstructor = True, group = Just "Forms" }
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.boolFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.intFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.floatFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.timePointFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.timePointSecFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.blockTimestampFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.nameFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.stringFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.checksumFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.publicKeyFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.signatureFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.symbolFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.symbolCodeFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.assetFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.extendedAssetFromString
        , Elm.exposeWith { exposeConstructor = True, group = Just "Forms" } Generate.Action.listFromString
        ]
    , prefixedFile [ "Action", "Metadata" ]
        { docs =
            [ "This file contains metadata about actions from the "
                ++ context.contract
                ++ " contract. You should only need this if you're building something like a contract explorer or an auto generated app."
            ]
        }
        [ Generate.Action.Metadata.allMetadata abi.actions
            |> Elm.exposeWith { exposeConstructor = True, group = Just "Metadata" }
        ]
    , prefixedFile [ "Table" ]
        { docs =
            [ "This file contains Elm types that represent all of the tables for the "
                ++ context.contract
                ++ " contract. You can query them with functions from the "
                ++ (fileName [ "Table", "Query" ]
                        |> List.map String.Extra.classify
                        |> String.join "."
                   )
                ++ " module, and perform the queries with [Eos.Query.send](Eos-Query#send)"
            ]
        }
        (List.map
            (Generate.Table.type_
                >> Elm.exposeWith
                    { exposeConstructor = False
                    , group = Just "Tables"
                    }
            )
            abi.tables
        )
    , prefixedFile [ "Table", "Metadata" ]
        { docs =
            [ "This file contains metadata about tables from the "
                ++ context.contract
                ++ " contract. You should only need this if you're building something like a contract explorer or an auto generated app"
            ]
        }
        [ Generate.Table.Metadata.typeUnion (fileName []) abi.tables
            |> Elm.exposeWith { exposeConstructor = True, group = Just "Metadata" }
        , Generate.Table.Metadata.allMetadata (fileName []) abi.tables
            |> Elm.exposeWith { exposeConstructor = True, group = Just "Metadata" }
        ]
    , prefixedFile [ "Table", "Decoder" ]
        { docs =
            [ "This file contains functions that decode the results of queries to the blockchain into types from "
                ++ (fileName [ "Table" ]
                        |> List.map String.Extra.classify
                        |> String.join "."
                   )
                ++ ". You probably won't need these! Just use [Eos.Query](Eos-Query), which will automatically decode things for you."
            ]
        }
        (Generate.Table.Decoder.generateIntDecoder
            :: List.map
                (Generate.Table.Decoder.generate context
                    >> Elm.exposeWith
                        { exposeConstructor = True
                        , group = Just "Decoders"
                        }
                )
                abi.tables
        )
    , prefixedFile [ "Table", "Query" ]
        { docs =
            [ "This is the file you want to use to query the blockchain for data, along with [Eos.Query.send](Eos-Query#send)." ]
        }
        (List.map
            (Generate.Table.Query.generateQuery context
                >> Elm.exposeWith
                    { exposeConstructor = True
                    , group = Just "Queries"
                    }
            )
            abi.tables
        )
    ]
