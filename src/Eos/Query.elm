module Eos.Query exposing
    ( Query(..)
    , send
    , Response
    , withBaseUrl, withLimit, withLowerBound, withUpperBound, withReverse
    , Cursor
    , Index(..)
    , map
    )

{-| Perform queries to get data from tables. The CLI gives you functions to perform
type-safe queries, and this module helps you actually turn them into Cmds.

@docs Query

@docs send

@docs Response

@docs withBaseUrl, withLimit, withLowerBound, withUpperBound, withReverse

@docs Cursor

@docs Index

@docs map

-}

import Http
import Json.Decode
import Json.Encode as Encode
import Url.Builder



-- QUERY


{-| The `Query` type. It's only exposed so that the CLI can have access to it.
You shouldn't construct it by hand.
-}
type Query response
    = Query
        { scope : String
        , indexPosition : Maybe Index
        , lowerBound : Maybe Cursor
        , upperBound : Maybe Cursor
        , limit : Maybe Int
        , reverse : Bool
        , baseUrl : String
        , contract : String
        , table : String
        , decoder : Json.Decode.Decoder response
        }



-- SEND


{-| Send a [Query](#Query) to EOSIO.

You shouldn't need to construct a [Query](#Query) by hand. Instead, use functions
generated by the CLI. They live in the Table.Query module.

Some parameters of the query are defined when running the CLI (like `baseUrl`).
Others can be modified with functions like [withLimit](#withLimit) and
[withBaseUrl](#withBaseUrl) (in case you need to override it).

This returns a [Response](#Response), since there may be pagination in the result.
If you want to paginate, keep the [Cursor](#Cursor) returned in the
[Response](#Response) and use [withLowerBound](#withLowerBound) or
[withUpperBound](#withUpperBound) in the next query.

    import Eos.Query
    import Http
    import Table
    import Table.Query

    type Msg
        = GotAccountData (Result Http.Error (Eos.Query.Response Table.Accounts))

    queryAccounts : Cmd Msg
    queryAccounts =
        Table.Query.accounts { scope = "henriquebuss" }
            |> Eos.Query.withLimit 20
            |> Eos.Query.send GotAccountData

-}
send : (Result Http.Error (Response response) -> msg) -> Query response -> Cmd msg
send toMsg (Query query) =
    let
        encodeOptional : (a -> Encode.Value) -> Maybe a -> Encode.Value
        encodeOptional encoder maybeValue =
            case maybeValue of
                Just value ->
                    encoder value

                Nothing ->
                    Encode.null
    in
    Http.post
        { body =
            Encode.object
                [ ( "code", Encode.string query.contract )
                , ( "table", Encode.string query.table )
                , ( "scope", Encode.string query.scope )
                , ( "index_position", encodeOptional encodeIndex query.indexPosition )
                , ( "lower_bound", encodeOptional encodeCursor query.lowerBound )
                , ( "upper_bound", encodeOptional encodeCursor query.upperBound )
                , ( "limit", encodeOptional Encode.int query.limit )
                , ( "reverse", Encode.bool query.reverse )
                , ( "json", Encode.bool True )
                ]
                |> Http.jsonBody
        , expect =
            Json.Decode.map3
                (\hasMore nextCursor result ->
                    { hasMore = hasMore
                    , nextCursor = nextCursor
                    , result = result
                    }
                )
                (Json.Decode.field "more" Json.Decode.bool)
                (Json.Decode.field "next_key"
                    (Json.Decode.map Cursor Json.Decode.string)
                )
                (Json.Decode.field "rows" (Json.Decode.list query.decoder))
                |> Http.expectJson toMsg
        , url = Url.Builder.crossOrigin query.baseUrl [ "get_table_rows" ] []
        }


encodeCursor : Cursor -> Encode.Value
encodeCursor (Cursor cursor) =
    Encode.string cursor


encodeIndex : Index -> Encode.Value
encodeIndex index =
    case index of
        Primary ->
            Encode.string "primary"

        Secondary ->
            Encode.string "secondary"

        Tertiary ->
            Encode.string "tertiary"

        Fourth ->
            Encode.string "fourth"

        Fifth ->
            Encode.string "fifth"

        Sixth ->
            Encode.string "sixth"

        Seventh ->
            Encode.string "seventh"

        Eighth ->
            Encode.string "eighth"

        Ninth ->
            Encode.string "ninth"

        Tenth ->
            Encode.string "tenth"



-- RESPONSE


{-| A response from a [Query](#Query). It contains the results, and also
pagination data. You can check if there is more data to be fetched with the
`hasMore` field. If there is, you can use the `nextCursor` field to fetch the
next page of data with [withLowerBound](#withLowerBound) or
[withUpperBound](#withUpperBound).
-}
type alias Response response =
    { hasMore : Bool
    , nextCursor : Cursor
    , result : List response
    }



-- MODIFIERS


{-| Redefine the base url to [send](#send) a [Query](#Query). This is already
defined when running the CLI, so you shouldn't need this function often.
-}
withBaseUrl : String -> Query response -> Query response
withBaseUrl baseUrl (Query query) =
    Query { query | baseUrl = baseUrl }


{-| Set how many entries to fetch on [send](#send).
-}
withLimit : Int -> Query response -> Query response
withLimit limit (Query query) =
    Query { query | limit = Just limit }


{-| Define the lower bound of a [Query](#Query). This is used to paginate the
results. You can get a [Cursor](#Cursor) from a [Response](#Response), which you
can get with [send](#send).
-}
withLowerBound : Cursor -> Query response -> Query response
withLowerBound cursor (Query query) =
    Query { query | lowerBound = Just cursor }


{-| Define the upper bound of a [Query](#Query). This is used to paginate the
results. You can get a [Cursor](#Cursor) from a [Response](#Response), which you
can get with [send](#send).
-}
withUpperBound : Cursor -> Query response -> Query response
withUpperBound cursor (Query query) =
    Query { query | upperBound = Just cursor }


{-| Define if the [Query](#Query) results should be reversed.
-}
withReverse : Bool -> Query response -> Query response
withReverse reverse (Query query) =
    Query { query | reverse = reverse }



-- CURSOR


{-| Used to set the lower bound or upper bound with [withLowerBound](#withLowerBound)
or [withUpperBound](#withUpperBound). You can get one of these from [send](#send).
-}
type Cursor
    = Cursor String



-- INDEX


{-| The Index to use when sending a [Query](#Query).
-}
type Index
    = Primary
    | Secondary
    | Tertiary
    | Fourth
    | Fifth
    | Sixth
    | Seventh
    | Eighth
    | Ninth
    | Tenth



-- UTILITY FUNCTIONS


{-| Map the response of a Query. This is here so the CLI can use it. You probably
shouldn't need to use it.
-}
map : (response -> mappedResponse) -> Query response -> Query mappedResponse
map mappingFunction (Query query) =
    Query
        { scope = query.scope
        , indexPosition = query.indexPosition
        , lowerBound = query.lowerBound
        , upperBound = query.upperBound
        , limit = query.limit
        , reverse = query.reverse
        , baseUrl = query.baseUrl
        , contract = query.contract
        , table = query.table
        , decoder = Json.Decode.map mappingFunction query.decoder
        }
